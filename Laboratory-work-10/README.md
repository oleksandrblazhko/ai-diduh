### 2.1 Теоретичне завдання зі створення історій виконання транзакцій

2.1.1 Історія квазіпаралельного успішного виконання транзакцій для протоколу 1-го ступеня блокування.
</br></br>
T1= R[A] R[B] W[A] C1</br>
T2= W[D] R[B] W[B] C2</br>
T3= R[D] W[D] C3</br>
</br></br>
**H(T1,T2,T3)=r1[A] r1[B] X1[A] w1[A] C1 r2[B] X1[B] w2[B] C2 r3[D] X2[D] w3[D] C3**

</br></br>

Таблиця блокувань:

| Назва         | Встановлені блокування        |          Запити на блокування |
|---------------|-------------------------------|-------------------------------|
| A             | X1                            |                               |
| B             | X1                            | X2                            |
| D             |                               |                               |



Опис таблиці блокування транзакцій до моменту першої фіксації змін однієї з транзакцій у вигляді масиву на мові програмування С:

```
char* lock_table[][3] = {
    { "A", "X1", "" },
    { "B", "X1", "X2" },
    { "D", "", "" }
};
```
</br></br>

2.1.2 Визначення Deadlock та граф очікування.
</br></br>
*(створимо граф очікування транзакцій)*
</br></br>
Граф очікування:</br>
T1 блокує [A] і [B]</br>
T2 блокує [D] і запитує [B], чекає звільнення [B] від T1</br>
T3 запитує [D] та чекає звільнення [D] від T2</br>
(Цикл: T1 → T2 → T3 → T1)
</br></br>

Масив для графа очікування у вигляді на мові С:

```
char* wait_graph[][2] = {
    { "T2", "T1" }, // T2 чекає T1
    { "T3", "T2" }, // T3 чекає T2
    { "T1", "T3" }  // T1 чекає T3
};
```
</br></br>
#### Висновок:
Граф очікування має цикл - наявність стану **Deadlock**. 

</br></br>

2.1.3 Історія квазіпаралельного успішного виконання транзакцій для протоколу 2-го ступеня блокування.
</br></br>
**H(T1,T2,T3)=r1[A] r1[B] X1[A] w1[A] X2[D] w2[D] X3[D]–Wait w1[B] C1 U1 X2[B] w2[B] C2 U2 X3[D] w3[D] C3 U3**
</br></br>
Таблиця блокувань:

| Назва         | Встановлені блокування        |          Запити на блокування |
|---------------|-------------------------------|-------------------------------|
| A             | X1                            |                               |
| B             | X1                            | X2                            |
| D             | X2                            | X3                            |
</br></br>
```
char* lock_table_2PL[][3] = {
    { "A", "X1", "" },   // A заблокована T1
    { "B", "X1", "X2" }, // B заблокована T1, запитано блокування від T2
    { "D", "X2", "X3" }  // D заблокована T2, запитано блокування від T3
};
```
</br></br>

2.1.4: Граф очікування
</br></br>
Масив для графа очікування транзакцій:

```
char* wait_graph[][2] = {
    { "T3", "T2" }  // T3 чекає на T2, !!! Deadlock не виникає
};
```
</br></br>
У цьому випадку є тільки один елемент очікування: T3 чекає на T2, але після фіксації T2 звільняє блокування [D], і T3 може завершити свою роботу без Deadlock.
</br></br>
#### Висновок:
Для протоколу 2-го ступеня блокування стану Deadlock - немає.</br></br>
</br></br></br></br>



